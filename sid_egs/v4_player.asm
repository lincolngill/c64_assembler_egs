#define MULTI_IRQ_SRCS // Use the multi IRQ source checking ISR

BasicUpstart2(start)
/* reRun with:
SYS49152
*/
//----------------------------------------------------------
//----------------------------------------------------------
//					SID player using IRQ From VIC Chip
// Keep normal CIA1 60Hz IRQ and handler
// Plus enable VIC raster compare IRQ to run music playing at 50Hz
// Plus return to BASIC interpreter loop.
//----------------------------------------------------------
//----------------------------------------------------------
/*
Refer: https://www.youtube.com/watch?v=EZAcD8aXVm4

Play SID music via Raster Compare VIC IRQ.
- Initialise player
- Setup VIC raster compare register for scan line 128
- Setup Raster compare interrupt and update vector to call our IRQ routine.
- The ISR:
   - Checks if it's a VIC IRQ.
   - If it is a VIC IRQ, checks if it's a compare raster source. If it is, play the music. Otherwise ignore it.
   - Checks if the CIA1 Timer A IRQ is set and calls the standard H/W ISR
   - Ignores all other interrupts. But the ISR is structured to expand for others if required.
- Relocate the start of Basic to after the Music binary segment.
- Call the Basic NEW routine and return to the Basic interpreter loop.
Music will continue to play in the background.
The BasicUpstart2 basic program will be gone.
A new Basic program can be created and run while the music plays.
*/		
//----------------------------------------------------------
			* = $C000 "IRQ SID Player v4"
start:
			lda #BLACK                 // Load A with Black colour code. $00
			sta $D020                  // Set the border colour
			lda #$00                   // Load A with track number
			jsr music_init
			sei                        // Disable interrupts
			/*
			Enable VIC raster compare IRQs
			$D019: VIC Interrupt Flag Register.
			   Read: If bit=1 then interrupt occurred.
			   Write: 1 bit=clear IRQ flag
			$D01A: VIC IRQ Mask Register. Set bit=1 to enble interrupts.
			   Bits for both Flag and Mask register:
			   7 - Any Enabled VIC IRQ Condition
			   6-4 - ?
			   3 - Light Pen IRQ
			   2 - Sprite to Sprite Collison
			   1 - Sprite to Background IRQ
			   0 - Raster Compare IRQ
			*/
			lda #$01                    // %00000001. VIC IRQ Mask. Raster Compare IRQs, are enabled. 
			sta $D01A
            /*
            Write 1 (bits) to $D019 to clear specific VIC IRQ flag.
			Note: When INC or ASL execute, they write to the location twice. First $FF then with the actual value.
			The $FF is enough for the VIC to register as setting all the flag bits, which clears the interrupts.
			INC $D019           - takes 3 bytes to code, 6 cycle to execute and doesn't disturb A but can set N and/or Z status bits.
			LDA #$FF; STA $D019 - takes 5 bytes to code and 6 cycle to execute.
			*/
            inc $D019                  // Small code footprint, to set ($D019)=#$FF
			/*
			Set 9-bit raster compare value to %010000000 = 128
			$D011: VIC Control Register
			   7 - Raster Compare: (Bit 8 or Most Significant Bit (MSB) of raster compare. aka. RC8). See $D012.
			   6 - Extended Colour Text Mode. 1=Enable
			   5 - Bit-Map Mode. 1=Enable
			   4 - Blank Screen to Border Colour. 0=Blank
			   3 - Select 24/25 Row Text. 1=25 rows
			   2-0 Smooth Scroll to Y Dot-Position (0-7)
			$D012: Raster Register
			   Read Raster. Lower 8bits of the current raster position.
			   Write Raster Value for Compare IRQ. Latched (Compare includes RC8 from $D011).
			      Internally the VIC compares the register with the current raster line. When they match it; sets the $D019 flag and raises an interrupt.

		    Visible display window is from raster 51 to 251 ($033 - $0FB) 
			*/
			lda #$80    // Raster compare IRQ at 128. I.e. 128-51=77 scan line down visible window. Or 77/200 = 38% down
			sta $D012   // The compare bits are latched for the VICs internal compare circuitry
			lda $D011   // Set RC8=0
			and #$7F    // And the current value with %01111111
			sta $D011
			/*
			Update Hardware IRQ vector to point to irq1 
			$0314 - Hardware IRQ Vector. Contains: $EA31 (in low-byte:high-byte order)
			The handler at $EA31 is used by BASIC & Kernal to scan keyboard, blink cursor and update clock.
			The interrupt is usually generated by CIA1 using Timer A. Running at 60Hz.
			irq1 will handle both:
			- The 60Hz CIA1 Timer A interrupt to handle the normal $EA31 routine; and
			- The PAL 50Hz raster compare interrupt to handle the SID playing

			When a H/W interrupt occurs:
			The CPU:
			   1) Pushes the PC and SR onto the stack
			   2) Loads the PC with the vector at ($FFFE) = $FF48 (Kernal ROM value)
			The ISR at $FF48:
			   3) Pushes the A, X and Y onto the stack
			   4) If the Break flag is set, it jumps to the BRK ISR at vector ($0316) = $FE66 (when initialised)
			   5) Otherwise it jumps to the ISR at the vector ($0314) = $EA31 (when initialised)
			*/
			lda #<irq1                 // Change the IRQ vector to call irq1
			sta $0314                  
			lda #>irq1
			sta $0315
			// $002B-$002C (43-44) - Update the start of BASIC mem address. Usually $0801
            lda #<basic_start          // Change start of BASIC mem to above the SID data
			sta $2B
			lda #>basic_start
			sta $2C                    // Zero page addressing
            /*
			Call the Basic NEW routine and return to the Basic interpreter command input loop.
			The NEW routine:
			- Resets the Basic text and variable pointers, based on the basic_start addr in $002B
			- Resets the basic code execution pointer at $007A to basic_start-1
			- Resets the SP to $FA, by:
			   - popping the top return address
			   - setting SP=$FA
			   - then pushes the saved return address back on the stack.
			I.e. it obliterates the call chain.

			At this pt in the code, the stack has:
			   $01F7 $46E1 - Return addr ($E146) to SYS routine from "10 SYS59152" BasicUpstart2 program or direct SYS59152 command.
			   $01F9 $E9A7 - Return addr to Basic command interpreter loop = $A7E9
			   $01FA A7 A6 AD A7 32 A5 - Not sure what these are.
			We don't want to return to the SYS call.
			Instead we can safely return to the Basic interpreter loop. If we make sure the next Basic byte = $00
			*/
			pla						   // Chuck away the SYS call return address that is on the stack
			pla
			/*
			The vector table for the Basic routines, holds the addr-1 of the routine location.
			The vector values are designed to be pushed onto the stack and invoked with RTS. (RTS loads the PC with the popped addr+1)
			*/
			lda $A051                  // Prepare to execute NEW command, via RTS
			pha
			lda $A050
			pha
			/*
			Make sure the byte at basic_start-1 is $00.
			The NEW call sets the BASIC execution pointer ($007A) = basic_start-1. I.e. ($002B)-1
			The RTS from NEW will return to the inner Basic interpreter loop.
			The interpreter gets the next byte via the exe pointer ($007A) and interprets a $00 as the end of the program.
			*/
			lda #$00                   // A=0 is also passed into NEW. Otherwise it will get a syntax error.
			sta basic_mem
			cli                        // Clear interrupt disable bit.
			rts                        // Jump back to BASIC via a NEW
//----------H/W ISR ---------------------------------------
#if MULTI_IRQ_SRCS
.print "ISR for multi IRQ sources"     // Basis for ISR that services any number of IRQ sources
irq1: {
            lda $D019                  // Read VIC IRQ flags
            and #%10001111             // Is it a VIC IRQ source? Note: bits 6-4 seem to be always set or floating. Best to mask them.
			beq cia1_isr               // No - Goto CIA1 check
vic_isr:                               // Yes - Process VIC IRQ(s)
			and #$01                   // Is it a VIC raster compare IRQ?
			beq vic_done               // No - Then ignore all others
			inc $D020                  // Change border colour
			jsr music_play             // Keep playing
			dec $D020                  // Change border colour back
vic_done:
            inc $D019                  // Clear all VIC IRQ flags.
cia1_isr:
            lda $DC0D                  // CIA Interrupt status bits are cleared when reg is read.
			tax                        // Save status in X for mutiple source checks.
			and #$01                   // Is the source the Timer A underflow IRQ? Must be last IRQ check because $EA31 includes the rti logic.
			beq return                 // No - Last check. So return.
            jmp $EA31                  // Yes - Goto normal H/W ISR.
return:                                // Only get here if CIA1 Timer A was not the source
     		pla                        // Pull Y. Need to restore Y,X & A if ISR is called via the Kernal ROM vectors.
			tay
			pla                        // Pull X
			tax
			pla                        // Pull A
			rti                        // Return from interrupt
}
#else
.print "ISR for VIC and Timer A IRQ sources"
irq1: {
            lda $D019                 // Read VIC IRQ flags
            and #%10001111            // Is it a VIC IRQ source? Note: bits 6-4 seem to be always set or floating. Best to mask them.
            bne vic_isr               // Yes - Then goto the VIC ISR code
            jmp $EA31                 // No  - Goto normal H/W ISR.
vic_isr:
			and #$01                   // Is it a VIC raster compare IRQ?
			beq return                 // No - Then ignore
			inc $D020                  // Change border colour
			jsr music_play             // Keep playing
			dec $D020                  // Change border colour back
return:
            inc $D019                  // Clear all VIC IRQ flags.
     		pla                        // Pull Y. Need to restore Y,X & A if ISR is called via the Kernal ROM vectors.
			tay
			pla                        // Pull X
			tax
			pla                        // Pull A
			rti                        // Return from interrupt
}
#endif
//----------------------------------------------------------
            /*
			$1000 - Common location to load a sid file
			The sid file includes the jmp vectors and code for music_init and music_play
			Call music_init once.
			Call music_play at 50-60 Hz
			*/
#define SID3           // SID file to play
#if SID1
            .const SID_FILE = "ode to 64.bin"
			*=$1000 "Music"
			.label music_init =*
			.label music_play =*+3
			.import binary SID_FILE
#elif SID2
            .const SID_FILE = "James_Bond_Theme_Remix.prg"
			*=$1000 "Music"
			.label music_init =*
			.label music_play =*+6
			.import c64 SID_FILE
#elif SID3
            .const SID_FILE = "Hey_Sister.prg"
			*=$5900 "Music"
			.label music_init =*
			.label music_play =*+3
			.import c64 SID_FILE
#elif SID4
            .const SID_FILE = "James_Bond.prg"
			*=$1000 "Music"
			.label music_init =*
			.label music_play =*+3
			.import c64 SID_FILE
#elif SID5
            .const SID_FILE = "Dancing_Queen.prg"
			*=$1000 "Music"
			.label music_init =*
			.label music_play =*+3
			.import c64 SID_FILE
#elif SID6
            .const SID_FILE = "Action_Biker_in_A.prg"
			*=$1000 "Music"
			.label music_init =*
			.label music_play =*+3
			.import c64 SID_FILE
#endif
			.print "SID File: " + SID_FILE 
			/*
			New BASIC start location. After the SID binary segment.
			Basic expects to see a $00 byte at basic_start-1
			*/
basic_mem:
			.byte $00
.label basic_start =*
.print "New Basic Starts at Mem: $" + toHexString(basic_start)